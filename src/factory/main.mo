// src/factory/main.mo
import Nat        "mo:base/Nat";
import Nat64      "mo:base/Nat64";
import Int        "mo:base/Int";
import Nat8       "mo:base/Nat8";
import Blob       "mo:base/Blob";
import Array      "mo:base/Array";
import Principal  "mo:base/Principal";
import Debug      "mo:base/Debug";

// Import generated bytes module: this expects src/factory/wasm_bytes_icrc1/lib.mo
import wasmICRC1 "wasm_bytes_icrc1";

actor TokenFactory {

  // Minimal management canister interface
  type ICManagement = actor {
    create_canister : ({ settings : ?{
      controllers : ?[Principal];
    }}) -> async { canister_id : Principal };

    install_code : ({
      mode         : { #install; #reinstall; #upgrade };
      canister_id  : Principal;
      wasm_module  : Blob;
      arg          : Blob;
    }) -> async ();
  };
  let ic : ICManagement = actor ("aaaaa-aa");

  // Types matching ledger DID subset
  type Account = { owner : Principal; subaccount : ?Blob };
  type Value =  { #Nat :Nat; #Int :Int; #Text :Text; #Blob :Blob };
  type ArchiveOptions = {
    trigger_threshold              : Nat64;
    num_blocks_to_archive          : Nat64;
    node_max_memory_size_bytes     : ?Nat64;
    max_message_size_bytes         : ?Nat64;
    controller_id                  : Principal;
  };
  type InitialBalance = { account : Account; amount : Nat };
  type LedgerInit = {
    token_symbol                     : Text;
    token_name                       : Text;
    minting_account                  : Account;
    transfer_fee                     : Nat;
    metadata                         : ?[(Text, Value)];
    initial_balances                 : [InitialBalance];
    archive_options                  : ArchiveOptions;
    feature_flags                    : ?{ icrc2 : Bool };
    maximum_number_of_accounts       : ?Nat64;
    accounts_overflow_trim_quantity  : ?Nat64;
  };

  // Project level types
  type Allocation = { owner : Principal; allocation : Nat };

  // helpers
  func percent(n : Nat, p : Nat) : Nat { (n * p) / 100 };

  func sumAll(xs : [Allocation]) : Nat {
    var s : Nat = 0;
    for (a in xs.vals()) { s += a.allocation };
    s
  };

  // Create ICRC-1 ledger canister with ICRC-2 enabled and tokenomics enforced
  public shared ({ caller }) func createFarmLedger(
    tokenName        : Text,
    tokenSymbol      : Text,
    farmerId         : Principal,
    initialSupply    : Nat,
    investorAllocs   : [Allocation],
    governance       : ?Principal,
    vestingDays      : Nat,
    transferFee      : Nat,
    extraControllers : [Principal],
    cyclesToSpend    : ?Nat
  ) : async Principal {
    assert initialSupply > 0;

    // Enforce tokenomics
    let reserveAmt : Nat = percent(initialSupply, 10);
    let maxInvest  : Nat = percent(initialSupply, 39);
    let investSum  : Nat = sumAll(investorAllocs);
    if (investSum > maxInvest) Debug.trap("Investor allocations exceed 39% cap");

    let farmerAllocation : Nat = initialSupply - reserveAmt - investSum;
    let minFarmer        : Nat = percent(initialSupply, 51);
    if (farmerAllocation < minFarmer) Debug.trap("Farmer allocation would fall below required 51%");

    // Build initial balances
    let farmerAccount : Account = { owner = farmerId; subaccount = null };

    let investorEntries : [InitialBalance] =
      Array.map<Allocation, InitialBalance>(investorAllocs, func (a : Allocation) : InitialBalance {
        { account = { owner = a.owner; subaccount = null }; amount = a.allocation }
      });

    let reserveAccount : Account = { owner = caller; subaccount = null };

    let initialBalances : [InitialBalance] =
      Array.append<InitialBalance>(
        [{ account = farmerAccount; amount = farmerAllocation }],
        Array.append<InitialBalance>(
          investorEntries,
          [{ account = reserveAccount; amount = reserveAmt }]
        )
      );

    // Minting authority record (record literal returned from each branch)
    let mintAuthority : Account = switch (governance) {
      case (?g) { { owner = g; subaccount = null } };
      case null  { { owner = farmerId; subaccount = null } };
    };

    // Archive options (sane local defaults)
    let archive : ArchiveOptions = {
      trigger_threshold = Nat64.fromNat(2000);
      num_blocks_to_archive = Nat64.fromNat(1000);
      node_max_memory_size_bytes = null;
      max_message_size_bytes = null;
      controller_id = caller;
    };

    // Prepare ledger init
    let init : LedgerInit = {
      token_symbol = tokenSymbol;
      token_name = tokenName;
      minting_account = mintAuthority;
      transfer_fee = transferFee;
      metadata = null;
      initial_balances = initialBalances;
      archive_options = archive;
      feature_flags = ?{ icrc2 = true };
      maximum_number_of_accounts = null;
      accounts_overflow_trim_quantity = null;
    };

    // Cycles amount (default for local dev)
    let defaultCycles : Nat = 1_000_000_000;
    let spend : Nat = switch (cyclesToSpend) { case (?n) n; case null defaultCycles };

    // controllers array: append caller + farmer + any extras (use Array.append<Principal>)
    let baseControllers : [Principal] = [caller, farmerId];
    let controllers : [Principal] = Array.append<Principal>(baseControllers, extraControllers);

    // Create canister and attach cycles to the call (preferred to Cycles.add)
    let { canister_id } = await (with cycles = spend) ic.create_canister({
      settings = ?{ controllers = ?controllers }
    });

    // Install code using the embedded wasm bytes
    let wasm : Blob = Blob.fromArray(wasmICRC1.array);
    let arg  : Blob = to_candid(init);

    await ic.install_code({
      mode        = #install;
      canister_id = canister_id;
      wasm_module = wasm;
      arg         = arg
    });

    canister_id
  };
}
